/*
* @Author: Yin
* @Date:   2018-12-09 22:01:11
* @Last Modified by:   Yin
* @Last Modified time: 2018-12-09 22:58:32
*/

function AdjustHeap(arr,pos,len){
	var swap=arr[pos];//将pos节点的数字保存
	var child = pos*2+1;//计算pos节点左子节点的位置
	while(child<len){//循环直到没有子节点
		if(child+1<len && arr[child]<arr[child+1]){//若pos子节点有右子节点且右子节点较大，用右子节点
			child+=1;
		}
		if(arr[pos]<arr[child]){//若pos节点小于较大子节点，则交换并将pos定位到子节点位置
			arr[pos]=arr[child];
			pos=child;
			child=pos*2+1;
			arr[pos]=swap;//将最初的pos节点存到pos指向的位置
		}
		else{
			break;
		}

	}
}
function heapSort(arr){
	for(var i=Math.floor(arr.length/2-1);i>=0;i--){//从第一个有子节点的节点开始建堆
		AdjustHeap(arr,i,arr.length);
	}
	for(var i=arr.length-1;i>0;i--){//取出堆的最大值后继续构建最大堆
		var temp=arr[i];
		arr[i]=arr[0];
		arr[0]=temp;
		AdjustHeap(arr,0,i);//对未排序的区域继续建堆
	}
	return arr;
}
/*二叉堆分为最大堆和最小堆。最大堆指堆中最大元素放在父节点，最小堆指堆中最小元素放在父节点。堆排序中用最大堆。

另外还需要知道堆的几个结论：

1、设某节点序号为i,则其父节点为⌊i/2⌋，2*i为左子节点序号，2*i+1为右子节点序号。其中，⌊⌋为向下取整符号。

2、当存储了n个元素时，⌊n/2⌋+1、⌊n/2⌋+1、···、n为叶节点。

二、保持堆性质

         保持堆性质就是保持最大堆性质，即其子节点不能大于父节点。为了达到这一性质，有以下操作：

从最后一个非叶节点（按照上面的结论2，最后一个非叶节点是⌊n/2⌋）开始，考察该节点和它的子节点的值的大小，

如果子节点比该元素大，则交换；这样整个交换过后可以保证最大的值肯定交换到了整个堆的根节点上。

但是这样会产生一个问题：设i为某非叶节点序号（值为A[i]），该节点的某一个子节点值比它大时交换；交换后，
值 A[i]成为了子节点的值。

但是当该子节点（交换后的A[i]）又是另一个子树的根节点时，可能出现它的子节点大于根节点的值A[i]的情况。

因此，对于值A[i]，要继续进行堆调整，即对值A[i]重复上面的工作。这样的结果是确保每一个子树都能符合最大堆。

三、建堆

         即从最后一个非叶节点⌊n/2⌋到1，进行保持堆性质操作。

四、堆排序算法

 1、在建好了最大堆后，交换节点1（设值为A[1]）和最后一个节点；由上面知，A[1]肯定是最大值。

2、交换后，将该节点（值为A[1]）移除（从堆结构中移除，不是从数组中移除）；

 3、移除后，对新堆的序号1（原来最后1一个节点的值）进行堆性质调整（即比较序号1和子节点的值大小，并交换）。

调整后重复步骤1、2。

最大值移除的目的在于得到最大值并放入排列结果数组中，并且缩短堆的长度，减少堆调整的时间。继续进行堆调整的目
的很明显是为了得到当前堆的最大值。

*/

 /* a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;

　　b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;

　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。*/

console.log(heapSort([3, 1, 5, 7, 2, 4, 9, 6, 10, 8,555,6,45,213,8784,211,5]));